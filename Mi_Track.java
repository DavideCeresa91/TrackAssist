/**

	This code was written by
	Dr. Davide Ceresa, PhD
	IRCCS Ospedale Policlinico San Martino, 16132 Genova, Italy
	email: davide.ceresa91@gmail.com
	and
	Prof. Paolo Malatesta, PhD 
	IRCCS Ospedale Policlinico San Martino, 16132 Genova, Italy
	Department of Experimental Medicine (DIMES), University of Genova, 16132 Genova, Italy
	email: paolo.malatesta@unige.it
	The code is intended for academic purposes only
	
*/

import ij.*;
import ij.plugin.filter.*;
import ij.plugin.*;
import ij.process.*;
import ij.gui.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import ij.measure.*;
import ij.io.*;
import java.io.*;
import ij.plugin.*;
import ij.text.*;
import ij.io.FileInfo;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;

/**


	This plugin implements the MouseListener interface and listens
	for mouse events generated by the current image.
	To trace use the following commands
	
	Shift: trace forward 4 step
	Control: trace forword 1 step
	ShiftControl: Cell Division
	ShiftAlt: Back to last division and track the other sister
	Alt: Cell death
	
	-Destructive commands
	ControlAlt: End of analysis
	ControlAltShift: go to the ancestor of the current cell and KILL the current branch and its sister 
	ShiftMeta: erase the point.
	
*/
public class Mi_Track implements PlugInFilter, MouseListener {
	
	class cellPosition {
		int x;
		int y;
		boolean used;
		boolean isReal;
		boolean isDead;
		int[] Regione;
	}
	
	int slices; 
	cellPosition cp[][];
	int lineage; // global variable to keep track of originary cell for each lineage
	int currentCell; // global variable containing the "name" of current tracked element 
	java.awt.Color colore;
	// String[] Scelte;
	ImagePlus img;
	ImageCanvas canvas;
	BufferedWriter FileBwriter;
	ResultsTable rt = new ResultsTable();
	
	
	public int setup(String arg, ImagePlus img) {
		this.img = img;
		IJ.register(Mi_Track.class);
		return DOES_ALL;
	}
	
	public void run(ImageProcessor ip) {
		if (!check(img)) {
			return; //checks that the object is a stack and counts the slices
		else {
			
			SetLookupTable();
			
			
			setcolor();
			
			ImageWindow win = img.getWindow();
			lineage = 0;
			currentCell=1;
			rt.setHeading(0, "Lineage");
			rt.setHeading(1, "CellID");
			rt.setHeading(2, "Tracciata in");
			rt.setHeading(3, "Birthday");
			
			
			cp = new cellPosition[slices][256]; //reSets the results matrix - which is a global variable
			resettaCP();
			canvas = win.getCanvas();
			
			canvas.addMouseListener(this);
			String NomeFile=ScegliDestinazione(win.getTitle());   //Start opening output file
			if(NomeFile!=null){
				try {
					FileWriter fileWriter = new FileWriter(NomeFile);
					FileBwriter = new BufferedWriter(fileWriter);
					FileBwriter.write("Cellula,X,Y,Slide,Lineage,Actual,Dead");
					FileBwriter.newLine();
				}
				catch(IOException ex) {
					IJ.write("Error writing to file");
					return;
				}
			}  else {return;}  //End opening output file
			
		}
	}
	
	
	public void mousePressed(MouseEvent e) {
		int x = e.getX();
		int y = e.getY();
		int CurrSlice = img.getCurrentSlice();
		int tracciatain=CurrSlice;
		int offscreenX = canvas.offScreenX(x);
		int offscreenY = canvas.offScreenY(y);
		String mod = modifiers(e.getModifiers());
		
		//IJ.write("modificatori "+mod);	
		ImageProcessor proc = img.getProcessor(); //get the area around the position for the correction
		img.setColor(colore); //this will be used to draw the Roi perimeter
		//		proc.setLineWidth(1); //otherwhise it will disappare
		
		if (mod.equals("Shift") || mod.equals("Control")) {
			if (!RightPos(CurrSlice,currentCell,proc)){
				GenericDialog gd = new GenericDialog("ATTENZIONE");
				gd.addMessage("Sei nella slice sbagliata!");
				gd.hideCancelButton();
				gd.showDialog();
			}
			else{
				TrackCellPos(CurrSlice,currentCell,proc,offscreenX,offscreenY,false);
				if (mod.equals("Shift")) {
					if(CurrSlice < slices-4)
					{img.setSlice(CurrSlice + 4);
					} 
					else 
					{img.setSlice(slices);}
					} else if (CurrSlice < slices && mod.equals("Control")) {
					img.setSlice(CurrSlice + 1);
				}
				
			}
		}
		else if (mod.equals("ShiftControl")) {
			int ncells;
			ncells = 0;
			for(int i = 0; i < slices; i++){
				if(cp[i][currentCell-1].used){
					ncells++;
				}
			}
			if (ncells>1){
				if (cp[CurrSlice - 1][currentCell-1].used) {
				putRegione(proc, cp[CurrSlice - 1][currentCell-1]);}
				TrackCellPos(CurrSlice,currentCell,proc,offscreenX,offscreenY,false);
				for (int i=CurrSlice;i<slices+1;i++){
					if (cp[i - 1][currentCell-1].used) {
						img.setSlice(i);
						putRegione(proc, cp[i - 1][currentCell-1]);
						cp[i-1][currentCell-1].used=false;			
					}

				}
				img.setSlice(CurrSlice);
				currentCell=currentCell*2; //creates a new generation (a new node)
	
				WritePosTocp(CurrSlice,currentCell,proc,offscreenX,offscreenY,true,false);
				img.setSlice(CurrSlice + 1);
			}
			else{
				GenericDialog gd = new GenericDialog("ATTENZIONE");
				gd.addMessage("Due mitosi di seguito!");
				gd.hideCancelButton();
				gd.showDialog();
				
			}
		}
		
		else if (mod.equals("ShiftAlt")) {
			
			Recolor (currentCell,proc);
			currentCell=PrecedenteCellulaSospesa(currentCell);
			if(currentCell>1) {
				img.setSlice(FindFirst(currentCell-1));
			}
			else {
				nextRoot();
			}		
			
		}
		
		else if (mod.equals("ControlAlt")) {

			if (AskOK("Vuoi terminare l'analisi?"))
			{
				stampaCP();
				concludi();
			}
		}
		else if (mod.equals("ShiftControlAlt")) {
			
			if(AskOK("Il comando invocato è distruttivo: vuoi procedere?"))
			{
				if(((currentCell-(currentCell%2))/2)%2==1){
					if(!AskOK("Cellula dispari: Sicuro di voler cancellare anche il ramo pari?"))
				return;}
				currentCell=(currentCell-(currentCell%2))/2;
				int sliceFineAntenata=FindFirst(currentCell*2);
				cancellaramo(currentCell*2);
				cancellaramo(currentCell*2+1);
				
			img.setSlice(sliceFineAntenata);}
		}	
		else if(mod.equals("Alt")) {
			TrackCellPos(CurrSlice,currentCell,proc,offscreenX,offscreenY,true);
			Recolor (currentCell,proc);
			currentCell=PrecedenteCellulaSospesa(currentCell);
			if(currentCell>1) img.setSlice(FindFirst(currentCell-1));
			else {nextRoot();}
		}
		
		else if (mod.equals("ShiftMeta")) {
			if (cp[CurrSlice - 1][currentCell-1].used) {
				putRegione(img.getProcessor(), cp[CurrSlice - 1][currentCell-1]);
			}
			cp[CurrSlice - 1][currentCell-1].used = false;
			
		}
		aggiornaRT(tracciatain);
		
	} //end mouseEvent loop
	//***************************************************************
	
	public void cancellaramo(int primacel){
		if (Math.round(Math.log(primacel)/Math.log(2))<6){

			boolean existpari=false;
			for (int i=0;i<slices;i++){
				if(cp[i][primacel-1].used){
					existpari=true;

					cp[i][primacel-1].used=false;
					img.setSlice(i+1);
					putRegione(img.getProcessor(), cp[i][primacel-1]);
				}		
			}	
			boolean existdispari=false;
			for (int i=0;i<slices;i++){
				if(cp[i][primacel].used){
					existdispari=true;
					cp[i][primacel].used=false;

					img.setSlice(i+1);
					putRegione(img.getProcessor(), cp[i][primacel]);
				}		
			}
			if(existpari){
			cancellaramo(primacel*2);}
			if(existdispari){
			cancellaramo((primacel+1)*2);}

			return;
			}else{

		return;}
	}
	
	public void concludi(){

		
		canvas.removeMouseListener(this);
		try {
			FileBwriter.close(); //closing file
		}
		catch(IOException ex) {
			IJ.write("Error writing to file");
		}
	}
	public void stampaCP(){

		String bool;
		for(int i=0;i<256;i++){
			for (int j = 0; j < slices; j++) {
				if (cp[j][i].used) {   //writing on file
					try{
						FileBwriter.write(IJ.d2s(i+1,0)+",");
						FileBwriter.write(IJ.d2s(cp[j][i].x,0)+",");
						FileBwriter.write(IJ.d2s(cp[j][i].y,0)+",");
						FileBwriter.write(IJ.d2s(j+1,0)+",");
						FileBwriter.write(IJ.d2s(lineage,0)+",");
						if(cp[j][i].isReal) bool="1"; else bool="0";
						FileBwriter.write(bool+",");
						if(cp[j][i].isDead) bool="1"; else bool="0";
						FileBwriter.write(bool);
						FileBwriter.newLine();
					}
					catch(IOException ex) {

					}
				}
			}
		}
	}
	
	int FindFirst(int cell){
		int i=0;
		while(!cp[i][cell-1].used) i++;
		return(i+1);
	}
	
	public static String modifiers(int flags) {
		String s = "";
		if (flags == 0) {
			return "";
		}
		if ( (flags & Event.SHIFT_MASK) != 0) {
			s += "Shift";
		}
		if ( (flags & Event.CTRL_MASK) != 0) {
			s += "Control";
		}
		if ( (flags & Event.META_MASK) != 0) {
			s += "Meta";
		}
		if ( (flags & Event.ALT_MASK) != 0) {
			s += "Alt";
		}
		
		if (s.equals("")) {
			s = " [no modifiers]";
		}
		return s;
	}
	
	public void mouseReleased(MouseEvent e) {
	}
	
	public void mouseExited(MouseEvent e) {
	}
	
	public void mouseClicked(MouseEvent e) {
	}
	
	public void mouseEntered(MouseEvent e) {
	}
	
	public void putRegione(ImageProcessor ip, cellPosition trp) {
		int regsX = trp.x - 11;
		int regsY = trp.y - 11;
		int[] riga = new int[23];
		
		for (int li = 0; li < 23; li++) {
			for (int pix = 0; pix < 23; pix++) {
				riga[pix] = trp.Regione[pix + 23 * li];
				
			}
			ip.putRow(regsX, regsY + li, riga, 23);
			
		}
	}
	
	public void setcolor() {
		/*   GenericDialog gd = new GenericDialog("Color");
			gd.addChoice("Select Color", Scelte,
			"Yellow");
			gd.showDialog();
			if (gd.wasCanceled()) {
			colore = Color.yellow;
			}
		switch (gd.getNextChoiceIndex() + 1) {*/
		switch (lineage + 1){
			case 1:
			colore = new Color (255,0,0);
			break;
			case 2:
			colore = new Color (255,0,0);
			break;
			case 3:
			colore = new Color (255,0,0);
			break;
			case 4:
			colore = new Color (255,0,0);
			break;
			
			default:
			colore = new Color (230,230,230);
		}
		
	}
	
	public int[] getRegione(ImageProcessor ip, int X, int Y) {
		int[] Reg = new int[529];
		int regsX = X - 11;
		int regsY = Y - 11;
		int[] riga = new int[23];
		
		for (int li = 0; li < 23; li++) {
			ip.getRow(regsX, regsY + li, riga, 23);
			for (int pix = 0; pix < 23; pix++) {
				Reg[pix + li * 23] = riga[pix];
			}
		}
		return Reg;
	}
	
	public boolean check(ImagePlus cseries) {
		
		if (cseries == null) {
			IJ.beep();
			IJ.showMessage("No image");
			return false;
		}
		ImageStack cstack = cseries.getStack();
		slices = cstack.getSize();
		if (slices < 2) {
			IJ.showMessage("Stack is needed");
			return false;
		}
		
		return true;
	}  /*end of check*/
	
	public String ScegliDestinazione(String nomestack) {
		String [] nomepart=nomestack.split("\\.");
		SaveDialog SaveD = new SaveDialog("Select destination", nomepart[0], "");
		String Directory=SaveD.getDirectory();
		String fileName=SaveD.getFileName();
		String FullFileName =Directory+fileName;
		return (FullFileName);
	}//end chooseDestination
	
	
	
	public void TrackCellPos(int Slice,int CellID,ImageProcessor proc,int PosX, int PosY,boolean isdead)
	{
		WritePosTocp(Slice,CellID,proc,PosX,PosY,true,isdead);
		boolean prospective=true;
		int startS=Slice-1;
		if (startS<1) {
			prospective=false;
		}else
		{
			while (!cp[startS - 1][CellID-1].isReal){
				startS--; //StartS is the last frame in which CellID is phisically tracked
				if (startS<1){
					prospective=false;
					break;
				}
			}
		}
		if(prospective){
			double vPx=cp[startS- 1][CellID-1].x;
			double vPy=cp[startS- 1][CellID-1].y;
			double dx=(PosX-vPx)/(Slice-startS);
			double dy=(PosY-vPy)/(Slice-startS);
			
			for(int t=startS+1;t<Slice;t++){
				WritePosTocp(t,CellID,proc,(int)(vPx+(t-startS)*dx),(int)(vPy+(t-startS)*dy),false,false);
			}
		}
		
	} //end TrackCellPos
	
	public void WritePosTocp(int Slice,int CellID,ImageProcessor proc,int PosX, int PosY,boolean istracked,boolean isdead)
	
	{	
		img.setSlice(Slice);
		if (cp[Slice - 1][CellID-1].used) {
			putRegione(proc, cp[Slice - 1][CellID-1]);
		}
		cp[Slice - 1][CellID-1].used = true;
		cp[Slice - 1][CellID-1].x = PosX;
		cp[Slice - 1][CellID-1].y = PosY;
		cp[Slice - 1][CellID-1].Regione = getRegione(proc, PosX, PosY);
		cp[Slice - 1][CellID-1].isReal=istracked;
		cp[Slice - 1][CellID-1].isDead=isdead;
		proc.setLineWidth(1);
		proc.drawOval(PosX - 1, PosY - 1, 2, 2);
		proc.drawOval(PosX - 10, PosY - 10, 20, 20);
	} //end WritePosTocp
	
	boolean AskOK(String msg){
		IJ.beep();
		GenericDialog gd = new GenericDialog("ATTENZIONE");
		gd.addMessage(msg);
		gd.enableYesNoCancel("Si","No");
		gd.hideCancelButton();
		gd.showDialog();
		
		if (gd.wasOKed()) return true; 
		else return false;
		
	}
	
	void aggiornaRT(int tracciatain){
		int i=1;
		while(!cp[i-1][currentCell-1].used){
		i++;}
		rt.incrementCounter();
		rt.addValue(0,lineage);
		rt.addValue(1,currentCell);
		rt.addValue(2,tracciatain);
		rt.addValue(3,i);
		rt.show("Tracked cell");
	}
	
	void resettaCP() {
		for (int i = 0; i < slices; i++) {
			for (int j=0;j<256;j++){
				cellPosition tr = new cellPosition();
				tr.used = false;
				tr.isDead=false;
				cp[i][j] = tr;
			}
		}		
	}
	
	int PrecedenteCellulaSospesa(int enne){
		while(enne%2!=0) enne=(enne-1)/2;
		return (enne+1);
	}
	
	void nextRoot()
	{
		stampaCP();
		if(lineage==3) {concludi();}
		else {
			IJ.beep();
			lineage++;
			img.setSlice(1);
			setcolor();
			resettaCP();
		}
	}	
	
	void Bleach (int Slice, int CellID, ImageProcessor proc)
	{
		int PosX;
		int PosY;
		PosX = cp[Slice - 1][CellID-1].x;
		PosY = cp[Slice - 1][CellID-1].y;
		img.setSlice(Slice);
		proc.setLineWidth(1);
		proc.setColor(new Color(255,255,0));
		proc.drawOval(PosX - 1, PosY - 1, 2, 2);
		proc.drawOval(PosX - 10, PosY - 10, 20, 20);
		img.setSlice(Slice);
		
		
	}
	
	void Yellow (int CellID, ImageProcessor proc, boolean ndp)
	{
		int vectX[];
		vectX = new int [slices];
		int vectY[];
		vectY = new int [slices];
		boolean first;
		first = true;
		
		for (int i = 0; i<slices ; i++) {
			vectX[i] = cp[i][CellID-1].x;
			vectY[i] = cp[i][CellID-1].y;
		}
		for (int i = 0; i<slices ; i++) {
			if (vectX[i] == 0 && vectY[i] == 0){
				first = true;
			}
			else{
				if(!(first && ndp)){
					Bleach(i+1, CellID, proc);
				}
				first = false;
			}
		}
	}
	
	void Recolor (int n, ImageProcessor proc){
		int m;
		if (n % 2 != 0){
			m = PrecedenteCellulaSospesa(n);
			while (n>m){
				Yellow(n, proc, false);
				if (n % 2 == 1){
					n = n-1;
				}
				else {
					n = n/2;
				}
			}
		}
		Yellow(n, proc, true);
	}
	
	boolean RightPos (int Slice,int CellID,ImageProcessor proc){
		if (CellID != 1){
			boolean first;
			first = false;
			for (int i = 0; i<Slice; i++){
				first = first || cp[i][CellID-1].used;
			}
			first = !first;
			if (first && (CellID%2==1) ){

				int Birthday;
				Birthday = 0;
				do{
				Birthday++;}
				while(!cp[Birthday][CellID-2].used);
				Birthday++;
				if (Slice!=Birthday){

					return (false);
					
				}
				else {

					return(true);
					
				}
			}
			else {


				return(true);
				
			}
		}
		else {

			return(true);
		}
	}
	
	void SetLookupTable(){
	ImagePlus implut = IJ.getImage();
	String lutName = "Lookup_Tables/MiTrack.lut";	
	IndexColorModel cm = null;
	
	try {
	InputStream is = getClass().getResourceAsStream(lutName);
	cm = LutLoader.open(is);
	} catch(IOException e) {
	String msg = e.getMessage();
	if(msg==null || msg.equals(""))
	msg = ""+e;
	IJ.error("Lookup Tables", msg);
	return;
	}
	ImageProcessor ip= implut.getChannelProcessor();
	if(implut.isComposite())
	((CompositeImage)implut).setChannelColorModel(cm);
	else
	ip.setColorModel(cm);
	implut.updateAndRepaintWindow();
	}
	
}	